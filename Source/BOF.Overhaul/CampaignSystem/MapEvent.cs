using System;
using System.Collections.Generic;
using System.Linq;
using Helpers;
using TaleWorlds.CampaignSystem;
using TaleWorlds.CampaignSystem.Actions;
using TaleWorlds.CampaignSystem.Siege;
using TaleWorlds.Core;
using TaleWorlds.Library;
using TaleWorlds.Localization;
using TaleWorlds.ObjectSystem;

namespace BOF.CampaignSystem.CampaignSystem
{
  public sealed class MapEvent : MBObjectBase, IMapEntity
  {
    private const float BattleRetreatMinimumTime = 1f;
    private const float SiegeDefenderAdvantage = 2f;
    private const int MapEventSettlementSettingDistance = 3;
    [SaveableField(101)]
    private MapEventState _state;
    [SaveableField(102)]
    private MapEventSide[] _sides = new MapEventSide[2];
    public const float SiegeAdvantage = 1.5f;
    public bool DiplomaticallyFinished;
    private bool _attackersRanAway;
    [SaveableField(106)]
    private int _mapEventUpdateCount;
    [SaveableField(107)]
    private CampaignTime _nextSimulationTime;
    [SaveableField(108)]
    private CampaignTime _mapEventStartTime;
    [SaveableField(109)]
    private float _nextSettlementDamage;
    [SaveableField(110)]
    private MapEvent.BattleTypes _mapEventType;
    [SaveableField(112)]
    private int _lootedItemCount;
    [CachedData]
    public IMapEventVisual MapEventVisual;
    [SaveableField(114)]
    private bool _isVisible;
    private IBattleObserver _battleObserver;
    [SaveableField(116)]
    private bool FirstUpdateIsDone;
    [SaveableField(117)]
    private BattleState _battleState;
    private bool _isFinishCalled;
    private bool _battleResultsCalculated;
    private bool _battleResultsCommitted;
    private bool PlayerCaptured;
    private MapEventResultExplainer _battleResultExplainers;
    [SaveableField(125)]
    public float[] StrengthOfSide = new float[2];

    public static void AutoGeneratedStaticCollectObjectsMapEvent(
      object o,
      List<object> collectedObjects)
    {
      ((MBObjectBase) o).AutoGeneratedInstanceCollectObjects(collectedObjects);
    }

    protected override void AutoGeneratedInstanceCollectObjects(List<object> collectedObjects)
    {
      base.AutoGeneratedInstanceCollectObjects(collectedObjects);
      collectedObjects.Add((object) this.StrengthOfSide);
      collectedObjects.Add((object) this._sides);
      CampaignTime.AutoGeneratedStaticCollectObjectsCampaignTime((object) this._nextSimulationTime, collectedObjects);
      CampaignTime.AutoGeneratedStaticCollectObjectsCampaignTime((object) this._mapEventStartTime, collectedObjects);
      collectedObjects.Add((object) this.MapEventSettlement);
    }

    public static object AutoGeneratedGetMemberValuePreviousState(object o) => (object) ((MapEvent) o).PreviousState;

    public static object AutoGeneratedGetMemberValueMapEventSettlement(object o) => (object) ((MapEvent) o).MapEventSettlement;

    public static object AutoGeneratedGetMemberValuePosition(object o) => (object) ((MapEvent) o).Position;

    public static object AutoGeneratedGetMemberValueIsInvulnerable(object o) => (object) ((MapEvent) o).IsInvulnerable;

    public static object AutoGeneratedGetMemberValueRaidDamage(object o) => (object) ((MapEvent) o).RaidDamage;

    public static object AutoGeneratedGetMemberValueIsPlayerSimulation(object o) => (object) ((MapEvent) o).IsPlayerSimulation;

    public static object AutoGeneratedGetMemberValueStrengthOfSide(object o) => (object) ((MapEvent) o).StrengthOfSide;

    public static object AutoGeneratedGetMemberValue_state(object o) => (object) ((MapEvent) o)._state;

    public static object AutoGeneratedGetMemberValue_sides(object o) => (object) ((MapEvent) o)._sides;

    public static object AutoGeneratedGetMemberValue_mapEventUpdateCount(object o) => (object) ((MapEvent) o)._mapEventUpdateCount;

    public static object AutoGeneratedGetMemberValue_nextSimulationTime(object o) => (object) ((MapEvent) o)._nextSimulationTime;

    public static object AutoGeneratedGetMemberValue_mapEventStartTime(object o) => (object) ((MapEvent) o)._mapEventStartTime;

    public static object AutoGeneratedGetMemberValue_nextSettlementDamage(object o) => (object) ((MapEvent) o)._nextSettlementDamage;

    public static object AutoGeneratedGetMemberValue_mapEventType(object o) => (object) ((MapEvent) o)._mapEventType;

    public static object AutoGeneratedGetMemberValue_lootedItemCount(object o) => (object) ((MapEvent) o)._lootedItemCount;

    public static object AutoGeneratedGetMemberValue_isVisible(object o) => (object) ((MapEvent) o)._isVisible;

    public static object AutoGeneratedGetMemberValueFirstUpdateIsDone(object o) => (object) ((MapEvent) o).FirstUpdateIsDone;

    public static object AutoGeneratedGetMemberValue_battleState(object o) => (object) ((MapEvent) o)._battleState;

    public static MapEvent PlayerMapEvent => MobileParty.MainParty?.MapEvent;

    public BattleSideEnum PlayerSide => PartyBase.MainParty.Side;

    public void OnGameInitialized()
    {
      this.AttackerSide.OnGameInitialized();
      this.DefenderSide.OnGameInitialized();
    }

    //[SaveableProperty(100)]
    public MapEventState PreviousState { get; private set; }

    public MapEventState State
    {
      get => this._state;
      private set
      {
        if (this._state == value)
          return;
        this.PreviousState = this._state;
        this._state = value;
      }
    }

    public void BeginWait() => this.State = MapEventState.Wait;

    public void BeginPlayerSimulation() => this.State = MapEventState.BattleWithoutLeader;

    public void BeginAftermath() => this.State = MapEventState.Aftermath;

    public MapEventSide AttackerSide => this._sides[1];

    public MapEventSide DefenderSide => this._sides[0];

    public MapEventSide GetMapEventSide(BattleSideEnum side) => this._sides[(int) side];

    public TroopRoster GetMemberRosterReceivingLootShare(PartyBase party) => this._sides[(int) party.Side].MemberRosterForPlayerLootShare(party);

    public TroopRoster GetPrisonerRosterReceivingLootShare(PartyBase party) => this._sides[(int) party.Side].PrisonerRosterForPlayerLootShare(party);

    public ItemRoster GetItemRosterReceivingLootShare(PartyBase party) => this._sides[(int) party.Side].ItemRosterForPlayerLootShare(party);

    public IReadOnlyList<MapEventParty> PartiesOnSide(BattleSideEnum side) => (IReadOnlyList<MapEventParty>) this._sides[(int) side].Parties;

    public IEnumerable<PartyBase> InvolvedParties
    {
      get
      {
        MapEventSide[] mapEventSideArray = this._sides;
        for (int index = 0; index < mapEventSideArray.Length; ++index)
        {
          foreach (MapEventParty party in mapEventSideArray[index].Parties)
            yield return party.Party;
        }
        mapEventSideArray = (MapEventSide[]) null;
      }
    }

    //[SaveableProperty(103)]
    public Settlement MapEventSettlement { get; private set; }

    public bool AttackersRanAway => this._attackersRanAway;

    public void GetBattleRewards(
      PartyBase party,
      out float renownChange,
      out float influenceChange,
      out float moraleChange,
      out float goldChange,
      out float playerEarnedLootPercentage)
    {
      renownChange = 0.0f;
      influenceChange = 0.0f;
      moraleChange = 0.0f;
      goldChange = 0.0f;
      playerEarnedLootPercentage = 0.0f;
      foreach (MapEventSide side in this._sides)
      {
        foreach (MapEventParty party1 in side.Parties)
        {
          if (party == party1.Party)
          {
            renownChange = party1.GainedRenown;
            influenceChange = party1.GainedInfluence;
            moraleChange = party1.MoraleChange;
            goldChange = (float) (party1.PlunderedGold - party1.GoldLost);
            float totalContribution = (float) this.GetMapEventSide(party1.Party.Side).CalculateTotalContribution();
            playerEarnedLootPercentage = (float) (int) (100.0 * ((double) party1.ContributionToBattle / (double) totalContribution));
          }
        }
      }
    }

    //[SaveableProperty(111)]
    public Vec2 Position { get; private set; }

    public MapEvent.BattleTypes EventType => this._mapEventType;

    //[SaveableProperty(113)]
    public bool IsInvulnerable { get; set; }

    //[SaveableProperty(115)]
    public float RaidDamage { get; private set; }

    public bool IsFieldBattle => this._mapEventType == MapEvent.BattleTypes.FieldBattle;

    public bool IsRaid => this._mapEventType == MapEvent.BattleTypes.Raid;

    public bool IsForcingVolunteers => this._mapEventType == MapEvent.BattleTypes.IsForcingVolunteers;

    public bool IsForcingSupplies => this._mapEventType == MapEvent.BattleTypes.IsForcingSupplies;

    public bool IsSiegeAssault => this._mapEventType == MapEvent.BattleTypes.Siege;

    public bool IsHideoutBattle => this._mapEventType == MapEvent.BattleTypes.Hideout;

    public bool IsAlleyFight => this._mapEventType == MapEvent.BattleTypes.AlleyFight;

    public bool IsSallyOut => this._mapEventType == MapEvent.BattleTypes.SallyOut;

    public bool IsSiegeOutside => this._mapEventType == MapEvent.BattleTypes.SiegeOutside;

    public MapEvent() => this.MapEventVisual = Campaign.Current.VisualCreator.CreateMapEventVisual(this);

    public MapEvent(Vec2 position)
    {
      this.Position = position;
      this.MapEventVisual = Campaign.Current.VisualCreator.CreateMapEventVisual(this);
    }

    protected override void OnBeforeLoad()
    {
      this.OnUnregistered();
      this.IsReady = true;
    }

    public void OnAfterLoad()
    {
      if (!PartyBase.IsPositionOkForTraveling(this.Position))
      {
        Vec2 mapEventPosition = this.CalculateMapEventPosition(this.AttackerSide.LeaderParty, this.DefenderSide.LeaderParty);
        if (mapEventPosition != this.Position)
        {
          Vec2 vec2 = mapEventPosition - this.Position;
          foreach (PartyBase involvedParty in this.InvolvedParties)
          {
            if (involvedParty.IsMobile && involvedParty.MobileParty.EventPositionAdder.IsNonZero())
              involvedParty.MobileParty.EventPositionAdder += vec2;
          }
          this.Position = mapEventPosition;
        }
      }
      if (!this.IsFinalized)
      {
        this.MapEventVisual = Campaign.Current.VisualCreator.CreateMapEventVisual(this);
        this.MapEventVisual.Initialize(this.Position, this.GetBattleSizeValue(), this.AttackerSide.LeaderParty != PartyBase.MainParty && this.DefenderSide.LeaderParty != PartyBase.MainParty, this.IsVisible);
      }
      if (!this.IsRaid || this.MapEventSettlement.Party.MapEvent != null)
        return;
      this.FinalizeEvent();
    }

    public void Initialize(
      PartyBase attackerParty,
      PartyBase defenderParty,
      MapEvent.BattleTypes mapEventType = MapEvent.BattleTypes.None)
    {
      this.FirstUpdateIsDone = false;
      this._attackersRanAway = false;
      this.MapEventSettlement = (Settlement) null;
      this._mapEventType = mapEventType;
      this._mapEventUpdateCount = 0;
      this._sides[0] = new MapEventSide(this, BattleSideEnum.Defender, defenderParty);
      this._sides[1] = new MapEventSide(this, BattleSideEnum.Attacker, attackerParty);
      if (attackerParty.MobileParty != MobileParty.MainParty)
      {
        if (mapEventType == MapEvent.BattleTypes.Raid)
        {
          Debug.Print("A raid mapEvent has been started on " + (object) defenderParty.Name + "\n", color: Debug.DebugColor.DarkGreen, debugFilter: 64UL);
          Debug.Print("[DEBUG] " + (object) attackerParty.LeaderHero?.Name + " is raiding " + (object) attackerParty.MobileParty.AiBehaviorObject.Name + "\n", color: Debug.DebugColor.DarkRed, debugFilter: 256UL);
        }
        else if (defenderParty.IsSettlement && defenderParty.Settlement.IsFortification)
          Debug.Print("A siege mapEvent has been started on " + (object) defenderParty.Name + "\n", color: Debug.DebugColor.DarkCyan, debugFilter: 64UL);
      }
      if (attackerParty.IsMobile && attackerParty.MobileParty.CurrentSettlement != null)
      {
        this.MapEventSettlement = attackerParty.MobileParty.CurrentSettlement;
        Debug.Print(attackerParty.Name.ToString() + " is inside " + (object) this.MapEventSettlement.Name + " and MapEventSettlement is set.", color: Debug.DebugColor.Cyan, debugFilter: 49472UL);
      }
      else if (defenderParty.IsMobile && defenderParty.MobileParty.CurrentSettlement != null)
      {
        this.MapEventSettlement = defenderParty.MobileParty.CurrentSettlement;
        Debug.Print(defenderParty.Name.ToString() + " is inside " + (object) this.MapEventSettlement.Name + " and MapEventSettlement is set.", color: Debug.DebugColor.Cyan, debugFilter: 49472UL);
      }
      else if (attackerParty.IsMobile && attackerParty.MobileParty.BesiegedSettlement != null)
        Debug.Print(attackerParty.Name.ToString() + " is besieging " + (object) attackerParty.MobileParty.BesiegedSettlement.Name + " and MapEventSettlement is set.", color: Debug.DebugColor.Cyan, debugFilter: 49472UL);
      else if (defenderParty.IsMobile && defenderParty.MobileParty.BesiegedSettlement != null)
        Debug.Print(defenderParty.Name.ToString() + " is besieging " + (object) defenderParty.MobileParty.BesiegedSettlement.Name + " and MapEventSettlement is set.", color: Debug.DebugColor.Cyan, debugFilter: 49472UL);
      if (attackerParty.IsSettlement)
        this.MapEventSettlement = attackerParty.Settlement;
      else if (defenderParty.IsSettlement)
      {
        this.MapEventSettlement = defenderParty.Settlement;
        this.MapEventSettlement.LastAttackerParty = attackerParty.MobileParty;
        this.MapEventSettlement.PassedHoursAfterLastThreat = 24;
      }
      if (this.MapEventSettlement == null && (attackerParty == PartyBase.MainParty || defenderParty == PartyBase.MainParty))
      {
        Settlement nearestVillage = SettlementHelper.FindNearestVillage((Func<Settlement, bool>) (x => (double) x.Position2D.DistanceSquared(attackerParty.Position2D) < 9.0));
        if (nearestVillage != null)
          this.MapEventSettlement = nearestVillage;
      }
      this.Position = this.CalculateMapEventPosition(attackerParty, defenderParty);
      attackerParty.MapEventSide = this.AttackerSide;
      defenderParty.MapEventSide = this.DefenderSide;
      if (defenderParty.IsMobile && defenderParty.MobileParty.BesiegedSettlement != null)
      {
        foreach (PartyBase party in defenderParty.MobileParty.SiegeEvent.Parties)
        {
          if (party != defenderParty && party.IsMobile && party != PartyBase.MainParty && party.MobileParty.BesiegedSettlement == defenderParty.MobileParty.BesiegedSettlement && (party.MobileParty.Army == null || party.MobileParty.Army.LeaderParty == party.MobileParty))
            party.MapEventSide = this.DefenderSide;
        }
      }
      if (attackerParty.IsMobile && attackerParty.MobileParty.BesiegedSettlement != null && this.IsSiegeAssault)
      {
        foreach (PartyBase party in attackerParty.MobileParty.SiegeEvent.Parties)
        {
          if (party != attackerParty && party.IsMobile && party != MobileParty.MainParty.Party && party.MobileParty.BesiegedSettlement == attackerParty.MobileParty.BesiegedSettlement && (party.MobileParty.Army == null || party.MobileParty.Army.LeaderParty == party.MobileParty))
            party.MapEventSide = this.AttackerSide;
        }
      }
      this.State = MapEventState.Wait;
      this._mapEventStartTime = CampaignTime.Now;
      this._nextSimulationTime = MapEvent.CalculateNextSimulationTime();
      this._nextSettlementDamage = 0.0f;
      this.RaidDamage = 0.0f;
      switch (mapEventType)
      {
        case MapEvent.BattleTypes.Raid:
          ChangeVillageStateAction.ApplyBySettingToBeingRaided(this.MapEventSettlement, this.AttackerSide.LeaderParty.MobileParty);
          break;
        case MapEvent.BattleTypes.IsForcingVolunteers:
          ChangeVillageStateAction.ApplyBySettingToBeingForcedForVolunteers(this.MapEventSettlement, this.AttackerSide.LeaderParty.MobileParty);
          break;
        case MapEvent.BattleTypes.IsForcingSupplies:
          ChangeVillageStateAction.ApplyBySettingToBeingForcedForSupplies(this.MapEventSettlement, this.AttackerSide.LeaderParty.MobileParty);
          break;
      }
      CampaignEventDispatcher.Instance.OnMapEventStarted(this, attackerParty, defenderParty);
      if (this.MapEventSettlement != null && mapEventType != MapEvent.BattleTypes.AlleyFight)
        this.AddInsideSettlementParties(this.MapEventSettlement);
      if (this == MobileParty.MainParty.MapEvent)
        this.CheckNearbyPartiesToJoinMainPlayerMapEventBattle();
      this.MapEventVisual.Initialize(this.Position, this.GetBattleSizeValue(), this.AttackerSide.LeaderParty != PartyBase.MainParty && this.DefenderSide.LeaderParty != PartyBase.MainParty, this.IsVisible);
      this.BattleState = BattleState.None;
    }

    private Vec2 CalculateMapEventPosition(PartyBase attackerParty, PartyBase defenderParty)
    {
      Vec2 vec2;
      if (defenderParty.IsSettlement)
      {
        vec2 = defenderParty.Position2D;
      }
      else
      {
        vec2 = attackerParty.Position2D + defenderParty.Position2D;
        vec2 = new Vec2(vec2.x / 2f, vec2.y / 2f);
      }
      return vec2;
    }

    public bool IsWinnerSide(BattleSideEnum side)
    {
      if (this.BattleState == BattleState.DefenderVictory && side == BattleSideEnum.Defender)
        return true;
      return this.BattleState == BattleState.AttackerVictory && side == BattleSideEnum.Attacker;
    }

    private void AddInsideSettlementParties(Settlement relatedSettlement)
    {
      if (CampaignSiegeTestStatic.IsSiegeTestBuild)
        return;
      for (int index = relatedSettlement.Parties.Count<MobileParty>() - 1; index >= 0; --index)
      {
        MobileParty party = relatedSettlement.Parties[index];
        if (party.MapEvent != this && !party.IsCaravan && !party.IsVillager && (!party.IsGarrison || relatedSettlement == this.MapEventSettlement && (this._mapEventType == MapEvent.BattleTypes.Raid || this._mapEventType == MapEvent.BattleTypes.Siege || this._mapEventType == MapEvent.BattleTypes.SallyOut || relatedSettlement.InRebelliousState)) && (!party.IsMilitia || relatedSettlement == this.MapEventSettlement && !this.MapEventSettlement.InRebelliousState) && party != MobileParty.MainParty && party.AttachedTo != MobileParty.MainParty && party.IsActive)
        {
          if (party.MapFaction == this.AttackerSide.MapFaction)
            party.Party.MapEventSide = this.AttackerSide;
          else if (party.MapFaction == this.DefenderSide.MapFaction || party.MapFaction.IsBanditFaction && this.DefenderSide.MapFaction.IsBanditFaction && this.MapEventSettlement != null && this.MapEventSettlement.IsHideout)
            party.Party.MapEventSide = this.DefenderSide;
          else if (relatedSettlement == this.MapEventSettlement && !party.IsGarrison && !party.IsMilitia)
          {
            LeaveSettlementAction.ApplyForParty(party);
            party.SetMoveModeHold();
          }
        }
      }
    }

    private int GetBattleSizeValue()
    {
      if (this.IsSiegeAssault)
        return 4;
      int numberOfInvolvedMen = this.GetNumberOfInvolvedMen();
      if (numberOfInvolvedMen < 30)
        return 0;
      if (numberOfInvolvedMen < 80)
        return 1;
      return numberOfInvolvedMen >= 120 ? 3 : 2;
    }

    private static CampaignTime CalculateNextSimulationTime() => CampaignTime.Now + CampaignTime.Minutes(30L);

    public void AddInvolvedPartyInternal(PartyBase involvedParty, BattleSideEnum side)
    {
      if (involvedParty.LeaderHero != null && involvedParty.LeaderHero.Clan == Clan.PlayerClan && involvedParty != PartyBase.MainParty && side == BattleSideEnum.Defender && this.AttackerSide.LeaderParty != null)
      {
        bool flag = false;
        foreach (PartyBase involvedParty1 in this.InvolvedParties)
        {
          if (involvedParty1 == PartyBase.MainParty)
          {
            flag = true;
            break;
          }
        }
        if (!flag)
        {
          Settlement settlement1 = Hero.MainHero.HomeSettlement;
          float num1 = Campaign.MapDiagonalSquared;
          foreach (Settlement settlement2 in Settlement.All)
          {
            if (settlement2.IsVillage || settlement2.IsFortification)
            {
              float num2 = settlement2.Position2D.DistanceSquared(involvedParty.Position2D);
              if ((double) num2 < (double) num1)
              {
                num1 = num2;
                settlement1 = settlement2;
              }
            }
          }
          if (settlement1 != null)
          {
            TextObject text = GameTexts.FindText("str_party_attacked");
            text.SetTextVariable("CLAN_PARTY_NAME", involvedParty.Name);
            text.SetTextVariable("ENEMY_PARTY_NAME", this.AttackerSide.LeaderParty.Name);
            text.SetTextVariable("SETTLEMENT_NAME", settlement1.Name);
            InformationManager.AddQuickInformation(text);
          }
        }
      }
      if (this.IsSiegeAssault && involvedParty.MobileParty != null && involvedParty.MobileParty.CurrentSettlement == null && side == BattleSideEnum.Defender)
        this._mapEventType = MapEvent.BattleTypes.SiegeOutside;
      involvedParty.ResetTempXp();
      if (involvedParty == MobileParty.MainParty.Party && !this.IsSiegeAssault && !this.IsRaid)
        involvedParty.MobileParty.SetMoveModeHold();
      if (involvedParty == PartyBase.MainParty)
        involvedParty.MobileParty.ForceAiNoPathMode = false;
      this.RecalculateRenownValue(involvedParty);
      if (this.IsFieldBattle && involvedParty.IsMobile && involvedParty.MobileParty.BesiegedSettlement == null)
      {
        Vec2 vec2 = this.GetMapEventSide(side).LeaderParty.Position2D - this.Position;
        float a = vec2.Normalize();
        if (involvedParty != this.GetMapEventSide(side).LeaderParty)
        {
          int num = this.GetMapEventSide(side).Parties.Count<MapEventParty>((Func<MapEventParty, bool>) (p => p.Party.IsMobile)) - 1;
          involvedParty.MobileParty.EventPositionAdder = this.Position + vec2 * MathF.Max(a, 0.4f) + (float) ((num + 1) / 2 * (num % 2 == 0 ? 1 : -1)) * vec2.RightVec() * 0.4f - (involvedParty.Position2D + involvedParty.MobileParty.ArmyPositionAdder);
        }
        else
          involvedParty.MobileParty.EventPositionAdder = this.Position + vec2 * MathF.Max(a, 0.4f) - (involvedParty.Position2D + involvedParty.MobileParty.ArmyPositionAdder);
      }
      involvedParty.Visuals.SetMapIconAsDirty();
      if (involvedParty.IsMobile && involvedParty.MobileParty.Army != null && involvedParty.MobileParty.Army.LeaderParty == involvedParty.MobileParty)
      {
        foreach (MobileParty attachedParty in involvedParty.MobileParty.Army.LeaderParty.AttachedParties)
          attachedParty.Party.Visuals.SetMapIconAsDirty();
      }
      if (this.FirstUpdateIsDone && involvedParty == PartyBase.MainParty)
        this.CheckNearbyPartiesToJoinMainPlayerMapEventBattle();
      if (this.HasWinner && involvedParty.MapEventSide.MissionSide != this.WinningSide && involvedParty.NumberOfHealthyMembers > 0)
        this.BattleState = BattleState.None;
      if (!involvedParty.IsVisible)
        return;
      this.IsVisible = true;
    }

    public bool IsVisible
    {
      get => this._isVisible;
      private set
      {
        this._isVisible = value;
        this.MapEventVisual?.SetVisibility(value);
      }
    }

    public void PartyVisibilityChanged(PartyBase party, bool isPartyVisible)
    {
      if (isPartyVisible)
      {
        this.IsVisible = true;
      }
      else
      {
        bool flag = false;
        foreach (PartyBase involvedParty in this.InvolvedParties)
        {
          if (involvedParty != party && involvedParty.IsVisible)
          {
            flag = true;
            break;
          }
        }
        this.IsVisible = flag;
      }
    }

    public void RemoveInvolvedPartyInternal(PartyBase party)
    {
      party.Visuals?.SetMapIconAsDirty();
      if (party.IsMobile && party.MobileParty.Army != null && party.MobileParty.Army.LeaderParty == party.MobileParty)
      {
        foreach (MobileParty attachedParty in party.MobileParty.Army.LeaderParty.AttachedParties)
          attachedParty.Party.Visuals?.SetMapIconAsDirty();
      }
      if (this.IsFieldBattle && party.IsMobile)
      {
        party.MobileParty.EventPositionAdder = Vec2.Zero;
        foreach (MapEventSide side in this._sides)
        {
          MapEventParty[] array = side.Parties.ToArray<MapEventParty>();
          Vec2 vec2 = side.LeaderParty.Position2D - this.Position;
          float a = vec2.Normalize();
          for (int index = 0; index < array.Length; ++index)
          {
            PartyBase party1 = array[index].Party;
            if (party1.IsMobile && party1 != side.LeaderParty)
              party1.MobileParty.EventPositionAdder = this.Position + vec2 * MathF.Max(a, 0.4f) + (float) ((index + 1) / 2 * (index % 2 == 0 ? 1 : -1)) * vec2.RightVec() * 0.4f - (party1.Position2D + party1.MobileParty.ArmyPositionAdder);
          }
        }
      }
      if (party == PartyBase.MainParty && this.State == MapEventState.Wait)
      {
        this.AttackerSide.RemoveNearbyPartiesFromPlayerMapEvent();
        this.DefenderSide.RemoveNearbyPartiesFromPlayerMapEvent();
      }
      if (!party.IsVisible)
        return;
      this.PartyVisibilityChanged(party, false);
    }

    public int GetNumberOfInvolvedMen() => this.DefenderSide.RecalculateMemberCountOfSide() + this.AttackerSide.RecalculateMemberCountOfSide();

    public int GetNumberOfInvolvedMen(BattleSideEnum side) => this.GetMapEventSide(side).RecalculateMemberCountOfSide();

    private void UpgradeTroops()
    {
      this.DefenderSide.UpgradeTroops();
      this.AttackerSide.UpgradeTroops();
    }

    private void LootDefeatedParties(out bool playerCaptured, LootCollector lootCollector) => this.GetMapEventSide(this.DefeatedSide).CollectAll(lootCollector, out playerCaptured);

    public void AddCasualtiesInBattle(TroopRoster troopRoster, LootCollector lootCollector) => lootCollector.CasualtiesInBattle.Add(troopRoster);

    private int CalculatePlunderedGold()
    {
      float num1 = 0.0f;
      foreach (MapEventParty party1 in this.GetMapEventSide(this.DefeatedSide).Parties)
      {
        PartyBase party2 = party1.Party;
        if (party2.LeaderHero != null)
        {
          int goldLossAfterDefeat = Campaign.Current.Models.BattleRewardModel.CalculateGoldLossAfterDefeat(party2.LeaderHero);
          num1 += (float) goldLossAfterDefeat;
          party1.GoldLost = goldLossAfterDefeat;
        }
        else if (party2.IsMobile && party2.MobileParty.IsPartyTradeActive)
        {
          int num2 = party2.MobileParty.IsBandit ? (int) ((double) party2.MobileParty.PartyTradeGold * 0.5) : (int) ((double) party2.MobileParty.PartyTradeGold * 0.100000001490116);
          num1 += (float) num2;
          party1.GoldLost = num2;
        }
      }
      return (int) num1;
    }

    private void CalculateRenownShares(MapEventResultExplainer resultExplainers = null, bool forScoreboard = false)
    {
      if (this.BattleState != BattleState.AttackerVictory && this.BattleState != BattleState.DefenderVictory)
        return;
      (this.BattleState == BattleState.AttackerVictory ? this.AttackerSide : this.DefenderSide).DistributeRenown(resultExplainers, forScoreboard);
    }

    private void CalculateLootShares(LootCollector lootCollector)
    {
      if (this.BattleState != BattleState.AttackerVictory && this.BattleState != BattleState.DefenderVictory)
        return;
      (this.BattleState == BattleState.AttackerVictory ? this.AttackerSide : this.DefenderSide).DistributeLootAmongWinners(lootCollector);
    }

    private int GetSimulatedDamage(
      CharacterObject strikerTroop,
      CharacterObject strikedTroop,
      PartyBase strikerParty,
      PartyBase strikedParty,
      float strikerAdvantage)
    {
      return Campaign.Current.Models.CombatSimulationModel.SimulateHit(strikerTroop, strikedTroop, strikerParty, strikedParty, strikerAdvantage, this);
    }

    private void SimulateBattleForRound(BattleSideEnum side, float advantage)
    {
      int strikerSideIndex = (int) side;
      if (this.AttackerSide.NumRemainingSimulationTroops != 0 && this.DefenderSide.NumRemainingSimulationTroops != 0 && !this.SimulateSingleHit(strikerSideIndex, 1 - strikerSideIndex, advantage))
        return;
      bool isRoundWinnerDetermined = false;
      BattleState calculateWinner = this.GetCalculateWinner(ref isRoundWinnerDetermined);
      if (calculateWinner != BattleState.None)
      {
        this.BattleState = calculateWinner;
      }
      else
      {
        if (!isRoundWinnerDetermined)
          return;
        this.BattleObserver?.BattleResultsReady();
      }
    }

    public IBattleObserver BattleObserver
    {
      get => this._battleObserver;
      set => this._battleObserver = value;
    }

    private bool SimulateSingleHit(
      int strikerSideIndex,
      int strikedSideIndex,
      float strikerAdvantage)
    {
      MapEventSide side1 = this._sides[strikerSideIndex];
      MapEventSide side2 = this._sides[strikedSideIndex];
      UniqueTroopDescriptor uniqueTroopDescriptor1 = side1.SelectRandomSimulationTroop();
      UniqueTroopDescriptor uniqueTroopDescriptor2 = side2.SelectRandomSimulationTroop();
      CharacterObject allocatedTroop1 = side1.GetAllocatedTroop(uniqueTroopDescriptor1);
      CharacterObject allocatedTroop2 = side2.GetAllocatedTroop(uniqueTroopDescriptor2);
      PartyBase allocatedTroopParty1 = side1.GetAllocatedTroopParty(uniqueTroopDescriptor1);
      PartyBase allocatedTroopParty2 = side2.GetAllocatedTroopParty(uniqueTroopDescriptor2);
      int damage = this.GetSimulatedDamage(allocatedTroop1, allocatedTroop2, allocatedTroopParty1, allocatedTroopParty2, strikerAdvantage);
      if (damage <= 0)
        return false;
      if (this.IsPlayerSimulation && allocatedTroopParty2 == PartyBase.MainParty)
      {
        float damageMultiplier = Campaign.Current.Models.DifficultyModel.GetPlayerTroopsReceivedDamageMultiplier();
        damage = MBRandom.RoundRandomized((float) damage * damageMultiplier);
      }
      DamageTypes damageType = (double) MBRandom.RandomFloat < 0.300000011920929 ? DamageTypes.Blunt : DamageTypes.Cut;
      MapEvent.SimulationTroopState troopState;
      side2.ApplySimulationDamageToSelectedTroop(damage, damageType, out troopState, allocatedTroopParty1);
      bool isFinishingStrike = troopState == MapEvent.SimulationTroopState.Killed || troopState == MapEvent.SimulationTroopState.Wounded;
      side1.ApplySimulatedHitRewardToSelectedTroop(allocatedTroop1, allocatedTroop2, damage, isFinishingStrike);
      return isFinishingStrike;
    }

    private bool GetAttackersRunAwayChance()
    {
      if (this._mapEventUpdateCount <= 1 || this.AttackerSide.LeaderParty.LeaderHero == null || this.IsSallyOut)
        return false;
      float num1 = 0.0f;
      foreach (MapEventParty party in this.AttackerSide.Parties)
        num1 += party.Party.TotalStrength;
      float num2 = 0.0f;
      foreach (MapEventParty party in this.DefenderSide.Parties)
        num2 += party.Party.TotalStrength;
      if (this.IsSiegeAssault)
        num1 *= 0.6666667f;
      return (double) num2 > (double) num1 * 1.10000002384186 && (double) MBRandom.RandomFloat * (this._mapEventUpdateCount < 16 ? (double) MathF.Sqrt((float) this._mapEventUpdateCount / 16f) : 1.0) > (double) num1 / ((double) num2 * 1.10000002384186);
    }

    public void Update()
    {
      if (this._isFinishCalled)
        return;
      bool flag1 = false;
      if (this._sides[0].LeaderParty == null || this._sides[1].LeaderParty == null || !this._sides[0].LeaderParty.MapFaction.IsAtWarWith(this._sides[1].LeaderParty.MapFaction))
        this.DiplomaticallyFinished = true;
      if (!this.DiplomaticallyFinished)
      {
        if (this._mapEventType == MapEvent.BattleTypes.Raid)
        {
          if (this.DefenderSide.TroopCount == 0)
          {
            this._nextSettlementDamage += Campaign.Current.Models.RaidModel.CalculateHitDamage(this.AttackerSide, this.MapEventSettlement.SettlementHitPoints);
            if ((double) this._nextSettlementDamage > 0.05)
            {
              if (this.MapEventSettlement.IsVillage)
              {
                float num1 = this._nextSettlementDamage * 0.33f * this.MapEventSettlement.Village.Hearth;
                this.MapEventSettlement.Village.Hearth -= num1;
                Hero leaderHero = this.AttackerSide.LeaderParty.LeaderHero;
                if (leaderHero != null)
                {
                  int num2 = (int) num1 * 10;
                  if (num2 > 0)
                  {
                    if (leaderHero == Hero.MainHero)
                    {
                      TextObject text = GameTexts.FindText("str_plunder_gain_message");
                      text.SetTextVariable("GOLD", num2);
                      InformationManager.AddQuickInformation(text);
                    }
                    GiveGoldAction.ApplyBetweenCharacters((Hero) null, leaderHero, num2, true);
                  }
                }
              }
              this.MapEventSettlement.SettlementHitPoints -= this._nextSettlementDamage;
              this.RaidDamage += this._nextSettlementDamage;
              this.RaidDamage = MathF.Min(this.RaidDamage, 1f);
              int num3 = 0;
              foreach (MapEventParty party in this.AttackerSide.Parties)
                num3 += party.Party.MemberRoster.TotalManCount;
              if (num3 > 0)
              {
                float num4 = (float) (1.0 - (double) MathF.Max(0.0f, this.MapEventSettlement.SettlementHitPoints) / ((double) MathF.Max(0.0f, this.MapEventSettlement.SettlementHitPoints) + (double) this._nextSettlementDamage));
                int num5 = 0;
                foreach (ItemRosterElement itemRosterElement in this.MapEventSettlement.ItemRoster)
                  num5 += itemRosterElement.Amount;
                ItemRoster itemRoster = new ItemRoster();
                if (num5 > 0)
                {
                  int num6 = MBRandom.RoundRandomized((float) num5 * num4);
                  if (num6 > num5)
                    num6 = num5;
                  EquipmentElement rosterElement = this.MapEventSettlement.ItemRoster.First<ItemRosterElement>().EquipmentElement;
                  for (int index = 0; index < num6; ++index)
                  {
                    int num7 = (int) ((double) MBRandom.RandomFloat * (double) num5);
                    bool flag2 = false;
                    PartyBase partyBase = this.AttackerSide.LeaderParty;
                    foreach (ItemRosterElement itemRosterElement in this.MapEventSettlement.ItemRoster)
                    {
                      int amount = itemRosterElement.Amount;
                      num7 -= amount;
                      if (num7 < 0)
                      {
                        rosterElement = itemRosterElement.EquipmentElement;
                        int num8 = (int) ((double) MBRandom.RandomFloat * (double) num3);
                        foreach (MapEventParty party in this.AttackerSide.Parties)
                        {
                          num8 -= party.Party.MemberRoster.TotalManCount;
                          if (num8 < 0)
                          {
                            partyBase = party.Party;
                            flag2 = true;
                            break;
                          }
                        }
                      }
                      if (flag2)
                        break;
                    }
                    if (!rosterElement.IsEqualTo(EquipmentElement.Invalid))
                    {
                      this.MapEventSettlement.ItemRoster.AddToCounts(rosterElement, -1);
                      if (this._lootedItemCount % 2 == 1)
                      {
                        int number = 1;
                        if (rosterElement.Item.IsFood)
                        {
                          Hero leaderHero = partyBase.LeaderHero;
                          if ((leaderHero != null ? (leaderHero.GetPerkValue(DefaultPerks.Steward.EfficientCampaigner) ? 1 : 0) : 0) != 0)
                            ++number;
                        }
                        partyBase.ItemRoster.AddToCounts(rosterElement, number);
                        if (partyBase == PartyBase.MainParty)
                          itemRoster.AddToCounts(rosterElement, number);
                      }
                      ++this._lootedItemCount;
                      --num5;
                      rosterElement = EquipmentElement.Invalid;
                    }
                  }
                  if (itemRoster.Any<ItemRosterElement>())
                    CampaignEventDispatcher.Instance.OnItemsLooted(itemRoster);
                }
              }
              if ((double) this.MapEventSettlement.SettlementHitPoints <= 9.99999974737875E-06)
              {
                this.MapEventSettlement.SettlementHitPoints = 0.0f;
                this.BattleState = BattleState.AttackerVictory;
                flag1 = true;
                this.MapEventSettlement.Party.Visuals.RefreshLevelMask(this.MapEventSettlement.Party);
              }
              this._nextSettlementDamage = 0.0f;
            }
          }
          else if (this.AttackerSide.TroopCount == 0)
            flag1 = true;
          else if (this.IsSiegeAssault && this.MapEventSettlement.SiegeEvent != null && this.MapEventSettlement.SiegeEvent.BesiegerCamp.SiegeParties.IsEmpty<PartyBase>())
          {
            MobileParty besiegerParty = this.MapEventSettlement.SiegeEvent.BesiegerCamp.BesiegerParty;
            flag1 = besiegerParty != null && besiegerParty.AttachedParties.IsEmpty<MobileParty>() && besiegerParty.AttachedParties.All<MobileParty>((Func<MobileParty, bool>) (t => t.MemberRoster.TotalManCount - t.MemberRoster.TotalWounded == 0));
          }
        }
        if (((this.DefenderSide.TroopCount != 0 && this.AttackerSide.TroopCount != 0 || this._mapEventType == MapEvent.BattleTypes.Raid ? 0 : (this.FirstUpdateIsDone ? 1 : 0)) != 0 || this.DefenderSide.TroopCount > 0 && this.AttackerSide.TroopCount > 0 || !this.FirstUpdateIsDone && (this.DefenderSide.TroopCount > 0 || this._mapEventType != MapEvent.BattleTypes.Raid)) && this._nextSimulationTime.IsPast)
        {
          this._attackersRanAway = this._mapEventType != MapEvent.BattleTypes.Siege && this._mapEventType != MapEvent.BattleTypes.SallyOut && this._mapEventType != MapEvent.BattleTypes.Raid && this.GetAttackersRunAwayChance();
          ++this._mapEventUpdateCount;
          if (!this._attackersRanAway)
          {
            this.SimulateBattleSessionForMapEvent();
            this._nextSimulationTime = MapEvent.CalculateNextSimulationTime();
            this.FirstUpdateIsDone = true;
          }
          else
            flag1 = true;
        }
        if ((this._mapEventType != MapEvent.BattleTypes.Raid || this.DefenderSide.Parties.Count > 1) && this.BattleState != BattleState.None)
          flag1 = true;
      }
      else
      {
        flag1 = true;
        foreach (PartyBase involvedParty in this.InvolvedParties)
        {
          if (involvedParty.IsMobile && involvedParty.MobileParty != MobileParty.MainParty && (involvedParty.MobileParty.Army == null || involvedParty.MobileParty.Army.LeaderParty == involvedParty.MobileParty))
            involvedParty.MobileParty.RecalculateShortTermAi();
        }
      }
      if (!flag1)
        return;
      if (this._mapEventType == MapEvent.BattleTypes.Raid)
      {
        float? settlementHitPoints = this.MapEventSettlement?.SettlementHitPoints;
        double? nullable = settlementHitPoints.HasValue ? new double?((double) settlementHitPoints.GetValueOrDefault()) : new double?();
        double num = 1E-05;
        if (nullable.GetValueOrDefault() <= num & nullable.HasValue)
          this.ApplyRaidResult();
      }
      if (this.IsPlayerMapEvent && PlayerEncounter.Current != null)
      {
        if (this._mapEventType != MapEvent.BattleTypes.Raid)
          return;
        PlayerEncounter.Current.FinishRaid();
      }
      else
        this.FinishBattle();
    }

    private void CheckSiegeStageChange()
    {
      if (this.MapEventSettlement == null || !this.IsSiegeAssault)
        return;
      int num = this.AttackerSide.Parties.Sum<MapEventParty>((Func<MapEventParty, int>) (party => party.Party.NumberOfHealthyMembers));
      this.DefenderSide.Parties.Sum<MapEventParty>((Func<MapEventParty, int>) (party => party.Party.NumberOfHealthyMembers));
      if (num == 0)
        ;
    }

    public void SimulateBattleSetup()
    {
      if (this.IsSiegeAssault)
        this.CheckSiegeStageChange();
      foreach (MapEventSide side in this._sides)
        side.MakeReadyForSimulation();
    }

    public void SimulateBattleForRounds(int simulationRoundsDefender, int simulationRoundsAttacker)
    {
      bool isRoundWinnerDetermined = false;
      this.BattleState = this.GetCalculateWinner(ref isRoundWinnerDetermined);
      (float num1, float num2) = Campaign.Current.Models.CombatSimulationModel.GetBattleAdvantage(this.DefenderSide.LeaderParty, this.AttackerSide.LeaderParty, this._mapEventType, this.MapEventSettlement);
      int num3 = 0;
      while (0 < simulationRoundsAttacker + simulationRoundsDefender && this.BattleState == BattleState.None)
      {
        if ((double) MBRandom.RandomFloat < (double) ((float) simulationRoundsAttacker / (float) (simulationRoundsAttacker + simulationRoundsDefender)))
        {
          --simulationRoundsAttacker;
          this.SimulateBattleForRound(BattleSideEnum.Attacker, num2);
        }
        else
        {
          --simulationRoundsDefender;
          this.SimulateBattleForRound(BattleSideEnum.Defender, num1);
        }
        ++num3;
      }
    }

    private void SimulateBattleSessionForMapEvent()
    {
      this.SimulateBattleSetup();
      (int defenderRounds, int attackerRounds) simulationRoundsForBattle = Campaign.Current.Models.CombatSimulationModel.GetSimulationRoundsForBattle(this, this.DefenderSide.NumRemainingSimulationTroops, this.AttackerSide.NumRemainingSimulationTroops);
      this.SimulateBattleForRounds(simulationRoundsForBattle.defenderRounds, simulationRoundsForBattle.attackerRounds);
      this.SimulateBattleEndSession();
    }

    public void SimulatePlayerEncounterBattle()
    {
      (int defenderRounds, int attackerRounds) simulationRoundsForBattle = Campaign.Current.Models.CombatSimulationModel.GetSimulationRoundsForBattle(this, this.DefenderSide.NumRemainingSimulationTroops, this.AttackerSide.NumRemainingSimulationTroops);
      this.SimulateBattleForRounds(simulationRoundsForBattle.defenderRounds, simulationRoundsForBattle.attackerRounds);
    }

    private void SimulateBattleEndSession()
    {
      this.CommitXpGains();
      this.ApplyRewardsAndChanges();
      foreach (MapEventSide side in this._sides)
        side.EndSimulation();
    }

    public bool IsPlayerMapEvent => this == MapEvent.PlayerMapEvent;

    public bool IsFinished => this._state == MapEventState.WaitingRemoval;

    public BattleState BattleState
    {
      get => this._battleState;
      private set
      {
        if (value == this._battleState)
          return;
        this._battleState = value;
        if (this._battleState != BattleState.AttackerVictory && this._battleState != BattleState.DefenderVictory)
          return;
        this.OnBattleWon(this._battleState);
      }
    }

    public MapEventSide Winner
    {
      get
      {
        if (this.BattleState == BattleState.AttackerVictory)
          return this.AttackerSide;
        return this.BattleState != BattleState.DefenderVictory ? (MapEventSide) null : this.DefenderSide;
      }
    }

    private void OnBattleWon(BattleState winnerSide)
    {
      this.CalculateBattleResults(true);
      this.BattleObserver?.BattleResultsReady();
    }

    public BattleSideEnum WinningSide
    {
      get
      {
        if (this.BattleState == BattleState.AttackerVictory)
          return BattleSideEnum.Attacker;
        return this.BattleState != BattleState.DefenderVictory ? BattleSideEnum.None : BattleSideEnum.Defender;
      }
    }

    public BattleSideEnum DefeatedSide
    {
      get
      {
        if (this.BattleState == BattleState.AttackerVictory)
          return BattleSideEnum.Defender;
        return this.BattleState != BattleState.DefenderVictory ? BattleSideEnum.None : BattleSideEnum.Attacker;
      }
    }

    private BattleState GetCalculateWinner(ref bool isRoundWinnerDetermined)
    {
      BattleState battleState = BattleState.None;
      int simulationTroops1 = this.AttackerSide.NumRemainingSimulationTroops;
      int simulationTroops2 = this.DefenderSide.NumRemainingSimulationTroops;
      if (this.IsPlayerSimulation && !Hero.MainHero.IsWounded && this.InvolvedParties.Contains<PartyBase>(PartyBase.MainParty))
      {
        if (PartyBase.MainParty.Side == BattleSideEnum.Attacker)
        {
          if (simulationTroops1 == 0)
            isRoundWinnerDetermined = true;
          ++simulationTroops1;
        }
        else if (PartyBase.MainParty.Side == BattleSideEnum.Defender)
        {
          if (simulationTroops2 == 0)
            isRoundWinnerDetermined = true;
          ++simulationTroops2;
        }
      }
      if (simulationTroops1 == 0)
        battleState = BattleState.DefenderVictory;
      else if (simulationTroops2 == 0)
        battleState = BattleState.AttackerVictory;
      return battleState;
    }

    public void SetOverrideWinner(BattleSideEnum winner)
    {
      int num;
      switch (winner)
      {
        case BattleSideEnum.Defender:
          num = 1;
          break;
        case BattleSideEnum.Attacker:
          num = 2;
          break;
        default:
          num = 0;
          break;
      }
      this.BattleState = (BattleState) num;
    }

    public void SetDefenderPulledBack() => this.BattleState = BattleState.DefenderPullBack;

    public void ResetBattleState() => this.BattleState = BattleState.None;

    public bool CheckIfOneSideHasLost()
    {
      int num1 = this.DefenderSide.RecalculateMemberCountOfSide();
      int num2 = this.AttackerSide.RecalculateMemberCountOfSide();
      if (this.BattleState == BattleState.None && (num1 == 0 || num2 == 0))
        this.BattleState = num2 > 0 ? BattleState.AttackerVictory : BattleState.DefenderVictory;
      return this.BattleState == BattleState.AttackerVictory || this.BattleState == BattleState.DefenderVictory;
    }

    public ItemRoster ItemRosterForPlayerLootShare(PartyBase party) => this.GetMapEventSide(party.Side).ItemRosterForPlayerLootShare(party);

    public bool IsPlayerSergeant() => this.IsPlayerMapEvent && this.GetLeaderParty(this.PlayerSide) != PartyBase.MainParty && MobileParty.MainParty.Army != null && MobileParty.MainParty.Army.LeaderParty != MobileParty.MainParty;

    private void FinishBattle()
    {
      List<MobileParty> mobilePartyList = new List<MobileParty>();
      if (this._attackersRanAway)
      {
        foreach (MapEventParty party in this.AttackerSide.Parties)
        {
          if (party.Party.IsMobile)
            mobilePartyList.Add(party.Party.MobileParty);
        }
      }
      this._isFinishCalled = true;
      if (!this._battleResultsCalculated)
        this.CalculateBattleResults();
      this.ApplyBattleResults();
      this.UpgradeTroops();
      this.FinalizeEventAux();
      if (!this._attackersRanAway)
        return;
      foreach (MobileParty mobileParty in mobilePartyList)
      {
        if (mobileParty.IsActive && mobileParty.AttachedTo == null)
        {
          if (mobileParty.BesiegerCamp != null)
            mobileParty.BesiegerCamp = (BesiegerCamp) null;
          Vec2 pointAroundPosition = MobilePartyHelper.FindReachablePointAroundPosition(mobileParty.Party, mobileParty.Position2D, 3.1f, 3f, true);
          mobileParty.Position2D = pointAroundPosition;
          mobileParty.SetMoveModeHold();
        }
      }
    }

    public MapEventResultExplainer BattleResultExplainers => this._battleResultExplainers;

    public override string ToString() => "Battle: " + (object) this.AttackerSide.LeaderParty?.Name + " x " + (object) this.DefenderSide.LeaderParty.Name;

    public void CalculateBattleResults(bool forScoreBoard = false)
    {
      if (this._battleResultsCalculated)
        return;
      this._battleResultsCalculated = !forScoreBoard;
      LootCollector lootCollector = new LootCollector();
      if (this.IsPlayerMapEvent)
      {
        this._battleResultExplainers = new MapEventResultExplainer();
        if (PlayerEncounter.EncounteredPartySurrendered)
          this._sides[(int) this.DefeatedSide.GetOppositeSide()].ResetContributionToBattleToStrength();
      }
      if (this.BattleState != BattleState.AttackerVictory && this.BattleState != BattleState.DefenderVictory)
        return;
      int plunderedGold = this.CalculatePlunderedGold();
      if (!forScoreBoard)
      {
        this.LootDefeatedParties(out this.PlayerCaptured, lootCollector);
        this.CalculatePlunderedGoldShares((float) plunderedGold, this._battleResultExplainers);
      }
      if (!forScoreBoard)
        this.CalculateLootShares(lootCollector);
      this.CalculateRenownShares(this._battleResultExplainers, forScoreBoard);
    }

    private void CalculatePlunderedGoldShares(
      float totalPlunderedGold,
      MapEventResultExplainer resultExplainers = null)
    {
      if (this.BattleState != BattleState.AttackerVictory && this.BattleState != BattleState.DefenderVictory)
        return;
      (this.BattleState == BattleState.AttackerVictory ? this.AttackerSide : this.DefenderSide).CalculatePlunderedGoldShare(totalPlunderedGold, resultExplainers);
    }

    public void ApplyBattleResults()
    {
      if (this._battleResultsCommitted)
        return;
      this.CommitXpGains();
      this.ApplyRewardsAndChanges();
      this._battleResultsCommitted = true;
    }

    private void ApplyRewardsAndChanges()
    {
      foreach (MapEventSide side in this._sides)
        side.ApplyRewardsAndChanges();
    }

    private void CommitXpGains()
    {
      foreach (MapEventSide side in this._sides)
      {
        side.CommitXpGains();
        side.CommitSkillXpGains();
      }
    }

    private void ApplyRaidResult() => ChangeVillageStateAction.ApplyBySettingToLooted(this.MapEventSettlement, this.AttackerSide.LeaderParty.MobileParty);

    public void ResetBattleResults() => this._battleResultsCommitted = false;

    public bool IsFinalized => this._state == MapEventState.WaitingRemoval;

    public void FinalizeEvent() => this.FinalizeEventAux();

    private void FinalizeEventAux()
    {
      if (this.IsFinalized)
        return;
      this.State = MapEventState.WaitingRemoval;
      CampaignEventDispatcher.Instance.OnMapEventEnded(this);
      if (this.MapEventSettlement != null && this.MapEventSettlement.GetComponent(typeof (SettlementComponent)) != null)
      {
        if (this.IsSiegeAssault || this.IsSiegeOutside)
        {
          switch (this.BattleState)
          {
            case BattleState.DefenderVictory:
              SiegeEvent siegeEvent = this.MapEventSettlement.SiegeEvent;
              if (siegeEvent != null)
              {
                siegeEvent.BesiegerCamp.RemoveAllSiegeParties();
                break;
              }
              break;
            case BattleState.AttackerVictory:
              CampaignEventDispatcher.Instance.SiegeCompleted(this.MapEventSettlement, this.AttackerSide.LeaderParty.MobileParty, true, this.IsSiegeAssault || this.IsSallyOut);
              break;
          }
        }
        else if (this.IsSallyOut)
        {
          if (this.MapEventSettlement.Town != null && this.MapEventSettlement.Town.GarrisonParty != null && this.MapEventSettlement.Town.GarrisonParty.IsActive)
            this.MapEventSettlement.Town.GarrisonParty.SetMoveModeHold();
        }
        else if (this._mapEventType == MapEvent.BattleTypes.Raid)
        {
          if (this.DefenderSide.Parties.Count <= 1)
            CampaignEventDispatcher.Instance.RaidCompleted(this.BattleState == BattleState.AttackerVictory ? BattleSideEnum.Attacker : BattleSideEnum.Defender, this);
          if ((double) this.MapEventSettlement.SettlementHitPoints > 0.0)
            ChangeVillageStateAction.ApplyBySettingToNormal(this.MapEventSettlement);
        }
        else if (this._mapEventType == MapEvent.BattleTypes.IsForcingSupplies)
        {
          CampaignEventDispatcher.Instance.ForceSuppliesCompleted(this.BattleState == BattleState.AttackerVictory ? BattleSideEnum.Attacker : BattleSideEnum.Defender, this);
          ChangeVillageStateAction.ApplyBySettingToNormal(this.MapEventSettlement);
        }
        else if (this._mapEventType == MapEvent.BattleTypes.IsForcingVolunteers)
        {
          CampaignEventDispatcher.Instance.ForceVolunteersCompleted(this.BattleState == BattleState.AttackerVictory ? BattleSideEnum.Attacker : BattleSideEnum.Defender, this);
          ChangeVillageStateAction.ApplyBySettingToNormal(this.MapEventSettlement);
        }
        else if (this._mapEventType == MapEvent.BattleTypes.Hideout)
          CampaignEventDispatcher.Instance.OnHideoutBattleCompleted(this.BattleState == BattleState.AttackerVictory ? BattleSideEnum.Attacker : BattleSideEnum.Defender, this);
      }
      foreach (MapEventSide side in this._sides)
      {
        side.UpdatePartiesMoveState();
        side.HandleMapEventEnd();
      }
      this.MapEventVisual?.OnMapEventEnd();
      foreach (PartyBase involvedParty in this.InvolvedParties)
      {
        if (involvedParty.IsMobile)
          involvedParty.MobileParty.EventPositionAdder = Vec2.Zero;
        involvedParty.Visuals?.SetMapIconAsDirty();
        if (involvedParty.IsMobile && involvedParty.MobileParty.Army != null && involvedParty.MobileParty.Army.LeaderParty == involvedParty.MobileParty)
        {
          foreach (MobileParty attachedParty in involvedParty.MobileParty.Army.LeaderParty.AttachedParties)
            attachedParty.Party.Visuals.SetMapIconAsDirty();
        }
      }
      if (this._mapEventType != MapEvent.BattleTypes.Siege && this._mapEventType != MapEvent.BattleTypes.SiegeOutside && this._mapEventType != MapEvent.BattleTypes.SallyOut)
      {
        foreach (PartyBase involvedParty in this.InvolvedParties)
        {
          if (involvedParty.IsMobile && involvedParty != PartyBase.MainParty && involvedParty.MobileParty.BesiegedSettlement != null && (involvedParty.MobileParty.Army == null || involvedParty.MobileParty.Army.LeaderParty == involvedParty.MobileParty))
          {
            if (involvedParty.IsActive)
              EncounterManager.StartSettlementEncounter(involvedParty.MobileParty, involvedParty.MobileParty.BesiegedSettlement);
            else
              involvedParty.MobileParty.BesiegerCamp = (BesiegerCamp) null;
          }
        }
      }
      foreach (MapEventSide side in this._sides)
        side.Clear();
    }

    public CampaignTime BattleStartTime => this._mapEventStartTime;

    public bool HasWinner => this.BattleState == BattleState.AttackerVictory || this.BattleState == BattleState.DefenderVictory;

    //[SaveableProperty(123)]
    public bool IsPlayerSimulation { get; set; }

    public bool CanPartyJoinSide(PartyBase party, BattleSideEnum side)
    {
      IFaction mapFaction = party.MapFaction;
      BattleSideEnum side1 = side == BattleSideEnum.Defender ? BattleSideEnum.Attacker : BattleSideEnum.Defender;
      return !FactionManager.IsAtWarAgainstFaction(this.GetLeaderParty(side).MapFaction, mapFaction) && FactionManager.IsAtWarAgainstFaction(this.GetLeaderParty(side1).MapFaction, mapFaction);
    }

    public bool HasTroopsOnBothSides() => this.PartiesOnSide(BattleSideEnum.Attacker).Any<MapEventParty>((Func<MapEventParty, bool>) (party => party.Party.NumberOfHealthyMembers > 0)) & this.PartiesOnSide(BattleSideEnum.Defender).Any<MapEventParty>((Func<MapEventParty, bool>) (party => party.Party.NumberOfHealthyMembers > 0));

    public PartyBase GetLeaderParty(BattleSideEnum side) => this._sides[(int) side].LeaderParty;

    public float GetRenownValue(BattleSideEnum side) => this._sides[(int) side].RenownValue;

    public void RecalculateRenownValue(PartyBase party)
    {
      this.StrengthOfSide[(int) party.Side] += party.TotalStrength;
      foreach (MapEventSide side in this._sides)
        side.CalculateRenownAndValorValue(this.StrengthOfSide);
    }

    public void DoSurrender(BattleSideEnum side)
    {
      this.GetMapEventSide(side).Surrender();
      this.BattleState = side == BattleSideEnum.Defender ? BattleState.AttackerVictory : BattleState.DefenderVictory;
    }

    public BattleSideEnum GetOtherSide(BattleSideEnum side) => side != BattleSideEnum.Attacker ? BattleSideEnum.Attacker : BattleSideEnum.Defender;

    private void CheckNearbyPartiesToJoinMainPlayerMapEventBattle()
    {
      if (this.IsRaid || this.IsAlleyFight || this.IsSiegeAssault || this.MapEventSettlement != null && this.MapEventSettlement.IsHideout || this.IsRaid || this.IsAlleyFight || this.IsSiegeAssault || this.IsForcingSupplies || this.IsForcingVolunteers)
        return;
      foreach (MobileParty nearbyFreeParty in MapEvent.GetNearbyFreeParties(this.DefenderSide.LeaderParty.Position2D))
      {
        if (nearbyFreeParty.MapFaction.IsAtWarWith(this.DefenderSide.MapFaction) && !nearbyFreeParty.MapFaction.IsAtWarWith(this.AttackerSide.MapFaction))
          this.AttackerSide.AddNearbyPartyToPlayerMapEvent(nearbyFreeParty);
        else if (nearbyFreeParty.MapFaction.IsAtWarWith(this.AttackerSide.MapFaction) && !nearbyFreeParty.MapFaction.IsAtWarWith(this.DefenderSide.MapFaction))
          this.DefenderSide.AddNearbyPartyToPlayerMapEvent(nearbyFreeParty);
      }
    }

    public static MobileParty[] GetNearbyFreeParties(Vec2 battlePosition)
    {
      float radius = 4f;
      return Campaign.Current.MobilePartyLocator.FindPartiesAroundPosition(battlePosition, radius).Where<MobileParty>((Func<MobileParty, bool>) (x =>
      {
        if (x.MapEvent != null || x.CurrentSettlement != null || x.AttachedTo != null)
          return false;
        return x.IsLordParty || x.IsBandit || x.ShouldJoinPlayerBattles;
      })).ToArray<MobileParty>();
    }

    Vec2 IMapEntity.InteractionPosition => this.Position;

    TextObject IMapEntity.Name => this.GetName();

    bool IMapEntity.IsMobileEntity => false;

    IMapEntity IMapEntity.AttachedEntity => (IMapEntity) null;

    IPartyVisual IMapEntity.PartyVisual => (IPartyVisual) null;

    bool IMapEntity.ShowCircleAroundEntity => false;

    bool IMapEntity.OnMapClick(bool followModifierUsed) => false;

    void IMapEntity.OnOpenEncyclopedia()
    {
    }

    bool IMapEntity.IsMainEntity() => false;

    void IMapEntity.OnHover() => InformationManager.AddTooltipInformation(typeof (MapEvent), (object) this);

    bool IMapEntity.IsEnemyOf(IFaction faction) => false;

    bool IMapEntity.IsAllyOf(IFaction faction) => false;

    public void GetMountAndHarnessVisualIdsForPartyIcon(
      out string mountStringId,
      out string harnessStringId)
    {
      mountStringId = "";
      harnessStringId = "";
    }

    public enum BattleTypes
    {
      None,
      FieldBattle,
      Raid,
      IsForcingVolunteers,
      IsForcingSupplies,
      Siege,
      Hideout,
      AlleyFight,
      SallyOut,
      SiegeOutside,
    }

    public enum SimulationTroopState
    {
      Alive,
      Wounded,
      Killed,
      Routed,
    }
  }
}